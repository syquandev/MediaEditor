//
//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
//

#import "TSAttachmentPointer.h"
#import "MIMETypeUtil.h"
#import "OWSBackupFragment.h"
#import "TSAttachmentStream.h"
#import <SignalServiceKit/SignalServiceKit-Swift.h>

NS_ASSUME_NONNULL_BEGIN

NSString *NSStringForTSAttachmentPointerState(TSAttachmentPointerState value)
{
    switch (value) {
        case TSAttachmentPointerStateEnqueued:
            return @"Enqueued";
        case TSAttachmentPointerStateDownloading:
            return @"Downloading";
        case TSAttachmentPointerStateFailed:
            return @"Failed";
        case TSAttachmentPointerStatePendingMessageRequest:
            return @"PendingMessageRequest";
        case TSAttachmentPointerStatePendingManualDownload:
            return @"PendingManualDownload";
        default:
            return @"Invalid value";
    }
}

@interface TSAttachmentStream (TSAttachmentPointer)

- (CGSize)cachedMediaSize;

@end

#pragma mark -

@interface TSAttachmentPointer ()

@property (nonatomic) TSAttachmentPointerState state;

// Optional property.  Only set for attachments which need "lazy backup restore."
@property (nonatomic, nullable) NSString *lazyRestoreFragmentId;

@end

#pragma mark -

@implementation TSAttachmentPointer

- (nullable instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];
    if (!self) {
        return self;
    }

    // A TSAttachmentPointer is a yet-to-be-downloaded attachment.
    // If this is an old TSAttachmentPointer from another session,
    // we know that it failed to complete before the session completed.
    if (![coder containsValueForKey:@"state"]) {
        _state = TSAttachmentPointerStateFailed;
    }

    if (_pointerType == TSAttachmentPointerTypeUnknown) {
        _pointerType = TSAttachmentPointerTypeIncoming;
    }

    return self;
}

- (instancetype)initWithServerId:(UInt64)serverId
                          cdnKey:(NSString *)cdnKey
                       cdnNumber:(UInt32)cdnNumber
                             key:(NSData *)key
                          digest:(nullable NSData *)digest
                       byteCount:(UInt32)byteCount
                     contentType:(NSString *)contentType
                  sourceFilename:(nullable NSString *)sourceFilename
                         caption:(nullable NSString *)caption
                  albumMessageId:(nullable NSString *)albumMessageId
                  attachmentType:(TSAttachmentType)attachmentType
                       mediaSize:(CGSize)mediaSize
                        blurHash:(nullable NSString *)blurHash
                 uploadTimestamp:(unsigned long long)uploadTimestamp
{
    self = [super initWithServerId:serverId
                            cdnKey:cdnKey
                         cdnNumber:cdnNumber
                     encryptionKey:key
                         byteCount:byteCount
                       contentType:contentType
                    sourceFilename:sourceFilename
                           caption:caption
                    albumMessageId:albumMessageId
                          blurHash:blurHash
                   uploadTimestamp:uploadTimestamp];
    if (!self) {
        return self;
    }

    _digest = digest;
    _state = TSAttachmentPointerStateEnqueued;
    self.attachmentType = attachmentType;
    _pointerType = TSAttachmentPointerTypeIncoming;
    _mediaSize = mediaSize;

    return self;
}

- (instancetype)initForRestoreWithAttachmentStream:(TSAttachmentStream *)attachmentStream
{

    self = [super initForRestoreWithUniqueId:attachmentStream.uniqueId
                                 contentType:attachmentStream.contentType
                              sourceFilename:attachmentStream.sourceFilename
                                     caption:attachmentStream.caption
                              albumMessageId:attachmentStream.albumMessageId];
    if (!self) {
        return self;
    }

    _state = TSAttachmentPointerStateEnqueued;
    self.attachmentType = attachmentStream.attachmentType;
    _pointerType = TSAttachmentPointerTypeRestoring;
    _mediaSize = (attachmentStream.shouldHaveImageSize ? attachmentStream.cachedMediaSize : CGSizeZero);

    return self;
}

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
                  albumMessageId:(nullable NSString *)albumMessageId
                  attachmentType:(TSAttachmentType)attachmentType
                        blurHash:(nullable NSString *)blurHash
                       byteCount:(unsigned int)byteCount
                         caption:(nullable NSString *)caption
                          cdnKey:(NSString *)cdnKey
                       cdnNumber:(unsigned int)cdnNumber
                     contentType:(NSString *)contentType
                   encryptionKey:(nullable NSData *)encryptionKey
                        serverId:(unsigned long long)serverId
                  sourceFilename:(nullable NSString *)sourceFilename
                 uploadTimestamp:(unsigned long long)uploadTimestamp
                          digest:(nullable NSData *)digest
           lazyRestoreFragmentId:(nullable NSString *)lazyRestoreFragmentId
                       mediaSize:(CGSize)mediaSize
                     pointerType:(TSAttachmentPointerType)pointerType
                           state:(TSAttachmentPointerState)state
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId
                    albumMessageId:albumMessageId
                    attachmentType:attachmentType
                          blurHash:blurHash
                         byteCount:byteCount
                           caption:caption
                            cdnKey:cdnKey
                         cdnNumber:cdnNumber
                       contentType:contentType
                     encryptionKey:encryptionKey
                          serverId:serverId
                    sourceFilename:sourceFilename
                   uploadTimestamp:uploadTimestamp];

    if (!self) {
        return self;
    }

    _digest = digest;
    _lazyRestoreFragmentId = lazyRestoreFragmentId;
    _mediaSize = mediaSize;
    _pointerType = pointerType;
    _state = state;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

+ (nullable TSAttachmentPointer *)attachmentPointerFromProto:(SSKProtoAttachmentPointer *)attachmentProto
                                                albumMessage:(nullable TSMessage *)albumMessage
{
    return nil;
}

+ (NSArray<TSAttachmentPointer *> *)attachmentPointersFromProtos:
                                        (NSArray<SSKProtoAttachmentPointer *> *)attachmentProtos
                                                    albumMessage:(TSMessage *)albumMessage
{

    NSMutableArray *attachmentPointers = [NSMutableArray new];
    for (SSKProtoAttachmentPointer *attachmentProto in attachmentProtos) {
        TSAttachmentPointer *_Nullable attachmentPointer =
            [self attachmentPointerFromProto:attachmentProto albumMessage:albumMessage];
        if (attachmentPointer) {
            [attachmentPointers addObject:attachmentPointer];
        }
    }
    return [attachmentPointers copy];
}

- (BOOL)isDecimalNumberText:(NSString *)text
{
    return [text componentsSeparatedByCharactersInSet:[NSCharacterSet decimalDigitCharacterSet]].count == 1;
}

- (void)upgradeFromAttachmentSchemaVersion:(NSUInteger)attachmentSchemaVersion
{
    // Legacy instances of TSAttachmentPointer apparently used the serverId as their
    // uniqueId.
    if (attachmentSchemaVersion < 2 && self.serverId == 0) {
        if ([self isDecimalNumberText:self.uniqueId]) {
            // For legacy instances, try to parse the serverId from the uniqueId.
            self.serverId = [self.uniqueId integerValue];
        } else {
        }
    }
}

- (nullable OWSBackupFragment *)lazyRestoreFragmentWithTransaction:(SDSAnyReadTransaction *)transaction
{
    if (!self.lazyRestoreFragmentId) {
        return nil;
    }
    OWSBackupFragment *_Nullable backupFragment = [OWSBackupFragment anyFetchWithUniqueId:self.lazyRestoreFragmentId
                                                                              transaction:transaction];
    return backupFragment;
}

#pragma mark - Update With... Methods

- (void)markForLazyRestoreWithFragment:(OWSBackupFragment *)lazyRestoreFragment
                           transaction:(SDSAnyWriteTransaction *)transaction
{

    if (!lazyRestoreFragment.uniqueId) {
        // If metadata hasn't been saved yet, save now.
        [lazyRestoreFragment anyInsertWithTransaction:transaction];

    }
    [self anyUpdateAttachmentPointerWithTransaction:transaction
                                              block:^(TSAttachmentPointer *attachmentPointer) {
                                                  [attachmentPointer
                                                      setLazyRestoreFragmentId:lazyRestoreFragment.uniqueId];
                                              }];
}

- (void)anyWillInsertWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyWillInsertWithTransaction:transaction];

    [self checkForStreamOverwrite:transaction];
}

- (void)anyWillUpdateWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyWillUpdateWithTransaction:transaction];

    [self checkForStreamOverwrite:transaction];
}

- (void)checkForStreamOverwrite:(SDSAnyReadTransaction *)transaction
{
#ifdef DEBUG
    if (self.uniqueId.length > 0) {
        TSAttachment *_Nullable oldObject = [TSAttachment anyFetchWithUniqueId:self.uniqueId transaction:transaction];
        if ([oldObject isKindOfClass:[TSAttachmentStream class]]) {
            
        }
    } else {
    }
#endif
}

#if TESTABLE_BUILD
- (void)setAttachmentPointerStateDebug:(TSAttachmentPointerState)state
{
    self.state = state;
}
#endif

- (void)updateWithAttachmentPointerState:(TSAttachmentPointerState)state
                             transaction:(SDSAnyWriteTransaction *)transaction
{
    [self anyUpdateAttachmentPointerWithTransaction:transaction
                                              block:^(TSAttachmentPointer *attachmentPointer) {
                                                  attachmentPointer.state = state;
                                              }];
}

- (void)updateAttachmentPointerStateFrom:(TSAttachmentPointerState)oldState
                                      to:(TSAttachmentPointerState)newState
                             transaction:(SDSAnyWriteTransaction *)transaction
{
    [self anyUpdateAttachmentPointerWithTransaction:transaction
                                              block:^(TSAttachmentPointer *attachmentPointer) {
                                                  if (attachmentPointer.state == oldState) {
                                                      attachmentPointer.state = newState;
                                                  }
                                              }];
}

@end

NS_ASSUME_NONNULL_END
