//
//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
//

#import "TSOutgoingMessage.h"
#import "AppReadiness.h"
#import "ProtoUtils.h"
#import "SSKEnvironment.h"
#import "TSAttachmentStream.h"
#import "TSContactThread.h"
#import "TSGroupThread.h"
#import <SignalCoreKit/NSDate+OWS.h>
#import <SignalCoreKit/NSString+OWS.h>
#import <SignalServiceKit/SignalServiceKit-Swift.h>

NS_ASSUME_NONNULL_BEGIN

typedef NS_CLOSED_ENUM(NSUInteger, OutgoingGroupProtoResult) { OutgoingGroupProtoResult_AddedWithGroupAvatar,
    OutgoingGroupProtoResult_AddedWithoutGroupAvatar,
    OutgoingGroupProtoResult_Error };

NSString *const kTSOutgoingMessageSentRecipientAll = @"kTSOutgoingMessageSentRecipientAll";

NSString *NSStringForOutgoingMessageState(TSOutgoingMessageState value)
{
    switch (value) {
        case TSOutgoingMessageStateSending:
            return @"TSOutgoingMessageStateSending";
        case TSOutgoingMessageStateFailed:
            return @"TSOutgoingMessageStateFailed";
        case TSOutgoingMessageStateSent_OBSOLETE:
            return @"TSOutgoingMessageStateSent_OBSOLETE";
        case TSOutgoingMessageStateDelivered_OBSOLETE:
            return @"TSOutgoingMessageStateDelivered_OBSOLETE";
        case TSOutgoingMessageStateSent:
            return @"TSOutgoingMessageStateSent";
        case TSOutgoingMessageStatePending:
            return @"TSOutgoingMessageStatePending";
    }
}

NSString *NSStringForOutgoingMessageRecipientState(OWSOutgoingMessageRecipientState value)
{
    switch (value) {
        case OWSOutgoingMessageRecipientStateFailed:
            return @"OWSOutgoingMessageRecipientStateFailed";
        case OWSOutgoingMessageRecipientStateSending:
            return @"OWSOutgoingMessageRecipientStateSending";
        case OWSOutgoingMessageRecipientStateSkipped:
            return @"OWSOutgoingMessageRecipientStateSkipped";
        case OWSOutgoingMessageRecipientStateSent:
            return @"OWSOutgoingMessageRecipientStateSent";
        case OWSOutgoingMessageRecipientStatePending:
            return @"OWSOutgoingMessageRecipientStatePending";
    }
}

#pragma mark -

@interface TSMessage (Private)

- (void)removeAllAttachmentsWithTransaction:(SDSAnyWriteTransaction *)transaction;

@end

#pragma mark -

@interface TSOutgoingMessageRecipientState ()

@property (atomic) OWSOutgoingMessageRecipientState state;
@property (atomic, nullable) NSNumber *deliveryTimestamp;
@property (atomic, nullable) NSNumber *readTimestamp;
@property (atomic, nullable) NSNumber *viewedTimestamp;
@property (atomic, nullable) NSNumber *errorCode;
@property (atomic) BOOL wasSentByUD;

@end

#pragma mark -

@implementation TSOutgoingMessageRecipientState

@end

#pragma mark -

NSUInteger const TSOutgoingMessageSchemaVersion = 1;

@interface TSOutgoingMessage ()

@property (atomic) BOOL hasSyncedTranscript;
@property (atomic, nullable) NSString *customMessage;
@property (atomic, nullable) NSString *mostRecentFailureText;
@property (atomic) BOOL isFromLinkedDevice;
@property (atomic) TSGroupMetaMessage groupMetaMessage;
@property (nonatomic, readonly) NSUInteger outgoingMessageSchemaVersion;

@property (nonatomic, readonly) TSOutgoingMessageState legacyMessageState;
@property (nonatomic, readonly) BOOL legacyWasDelivered;
@property (nonatomic, readonly) BOOL hasLegacyMessageState;
@property (atomic, nullable)
    NSDictionary<SignalServiceAddress *, TSOutgoingMessageRecipientState *> *recipientAddressStates;

// This property is only intended to be used by GRDB queries.
@property (nonatomic, readonly) TSOutgoingMessageState storedMessageState;

@end

#pragma mark -

@implementation TSOutgoingMessage

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
             receivedAtTimestamp:(uint64_t)receivedAtTimestamp
                          sortId:(uint64_t)sortId
                       timestamp:(uint64_t)timestamp
                  uniqueThreadId:(NSString *)uniqueThreadId
                   attachmentIds:(NSArray<NSString *> *)attachmentIds
                            body:(nullable NSString *)body
                      bodyRanges:(nullable MessageBodyRanges *)bodyRanges
                 expireStartedAt:(uint64_t)expireStartedAt
                       expiresAt:(uint64_t)expiresAt
                expiresInSeconds:(unsigned int)expiresInSeconds
               isGroupStoryReply:(BOOL)isGroupStoryReply
              isViewOnceComplete:(BOOL)isViewOnceComplete
               isViewOnceMessage:(BOOL)isViewOnceMessage
                     linkPreview:(nullable OWSLinkPreview *)linkPreview
                  messageSticker:(nullable MessageSticker *)messageSticker
                   quotedMessage:(nullable TSQuotedMessage *)quotedMessage
    storedShouldStartExpireTimer:(BOOL)storedShouldStartExpireTimer
           storyAuthorUuidString:(nullable NSString *)storyAuthorUuidString
              storyReactionEmoji:(nullable NSString *)storyReactionEmoji
                  storyTimestamp:(nullable NSNumber *)storyTimestamp
              wasRemotelyDeleted:(BOOL)wasRemotelyDeleted
                   customMessage:(nullable NSString *)customMessage
                groupMetaMessage:(TSGroupMetaMessage)groupMetaMessage
           hasLegacyMessageState:(BOOL)hasLegacyMessageState
             hasSyncedTranscript:(BOOL)hasSyncedTranscript
              isFromLinkedDevice:(BOOL)isFromLinkedDevice
                  isVoiceMessage:(BOOL)isVoiceMessage
              legacyMessageState:(TSOutgoingMessageState)legacyMessageState
              legacyWasDelivered:(BOOL)legacyWasDelivered
           mostRecentFailureText:(nullable NSString *)mostRecentFailureText
          recipientAddressStates:(nullable NSDictionary<SignalServiceAddress *,TSOutgoingMessageRecipientState *> *)recipientAddressStates
              storedMessageState:(TSOutgoingMessageState)storedMessageState
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId
               receivedAtTimestamp:receivedAtTimestamp
                            sortId:sortId
                         timestamp:timestamp
                    uniqueThreadId:uniqueThreadId
                     attachmentIds:attachmentIds
                              body:body
                        bodyRanges:bodyRanges
                   expireStartedAt:expireStartedAt
                         expiresAt:expiresAt
                  expiresInSeconds:expiresInSeconds
                 isGroupStoryReply:isGroupStoryReply
                isViewOnceComplete:isViewOnceComplete
                 isViewOnceMessage:isViewOnceMessage
                       linkPreview:linkPreview
                     quotedMessage:quotedMessage
      storedShouldStartExpireTimer:storedShouldStartExpireTimer
             storyAuthorUuidString:storyAuthorUuidString
                storyReactionEmoji:storyReactionEmoji
                    storyTimestamp:storyTimestamp
                wasRemotelyDeleted:wasRemotelyDeleted];

    if (!self) {
        return self;
    }

    _customMessage = customMessage;
    _groupMetaMessage = groupMetaMessage;
    _hasLegacyMessageState = hasLegacyMessageState;
    _hasSyncedTranscript = hasSyncedTranscript;
    _isFromLinkedDevice = isFromLinkedDevice;
    _isVoiceMessage = isVoiceMessage;
    _legacyMessageState = legacyMessageState;
    _legacyWasDelivered = legacyWasDelivered;
    _mostRecentFailureText = mostRecentFailureText;
    _recipientAddressStates = recipientAddressStates;
    _storedMessageState = storedMessageState;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

- (nullable instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];

    if (self) {

        _outgoingMessageSchemaVersion = TSOutgoingMessageSchemaVersion;
    }


    return self;
}

+ (instancetype)outgoingMessageInThread:(TSThread *)thread
                            messageBody:(nullable NSString *)body
                           attachmentId:(nullable NSString *)attachmentId
{
    return [self outgoingMessageInThread:thread
                             messageBody:body
                            attachmentId:attachmentId
                        expiresInSeconds:0
                           quotedMessage:nil
                             linkPreview:nil
                          messageSticker:nil];
}

+ (instancetype)outgoingMessageInThread:(TSThread *)thread
                            messageBody:(nullable NSString *)body
                           attachmentId:(nullable NSString *)attachmentId
                       expiresInSeconds:(uint32_t)expiresInSeconds
{
    return [self outgoingMessageInThread:thread
                             messageBody:body
                            attachmentId:attachmentId
                        expiresInSeconds:expiresInSeconds
                           quotedMessage:nil
                             linkPreview:nil
                          messageSticker:nil];
}

+ (instancetype)outgoingMessageInThread:(TSThread *)thread
                            messageBody:(nullable NSString *)body
                           attachmentId:(nullable NSString *)attachmentId
                       expiresInSeconds:(uint32_t)expiresInSeconds
                          quotedMessage:(nullable TSQuotedMessage *)quotedMessage
                            linkPreview:(nullable OWSLinkPreview *)linkPreview
                         messageSticker:(nullable MessageSticker *)messageSticker
{
    NSMutableArray<NSString *> *attachmentIds = [NSMutableArray new];
    if (attachmentId) {
        [attachmentIds addObject:attachmentId];
    }

    TSOutgoingMessageBuilder *builder = [TSOutgoingMessageBuilder outgoingMessageBuilderWithThread:thread];
    builder.messageBody = body;
    builder.attachmentIds = attachmentIds;
    builder.expiresInSeconds = expiresInSeconds;
    builder.linkPreview = linkPreview;
    return [builder build];
}

+ (instancetype)outgoingMessageInThread:(TSThread *)thread
                       groupMetaMessage:(TSGroupMetaMessage)groupMetaMessage
                       expiresInSeconds:(uint32_t)expiresInSeconds
{
    TSOutgoingMessageBuilder *builder = [TSOutgoingMessageBuilder outgoingMessageBuilderWithThread:thread];
    builder.groupMetaMessage = groupMetaMessage;
    builder.expiresInSeconds = expiresInSeconds;
    return [builder build];
}

+ (instancetype)outgoingMessageInThread:(TSThread *)thread
                       groupMetaMessage:(TSGroupMetaMessage)groupMetaMessage
                       expiresInSeconds:(uint32_t)expiresInSeconds
                 changeActionsProtoData:(nullable NSData *)changeActionsProtoData
{
    TSOutgoingMessageBuilder *builder = [TSOutgoingMessageBuilder outgoingMessageBuilderWithThread:thread];
    builder.groupMetaMessage = groupMetaMessage;
    builder.expiresInSeconds = expiresInSeconds;
    builder.changeActionsProtoData = changeActionsProtoData;
    return [builder build];
}

- (instancetype)initOutgoingMessageWithBuilder:(TSOutgoingMessageBuilder *)outgoingMessageBuilder
{
    self = [super initMessageWithBuilder:outgoingMessageBuilder];
    if (!self) {
        return self;
    }

    _hasSyncedTranscript = NO;

    TSThread *thread = outgoingMessageBuilder.thread;
    TSGroupMetaMessage groupMetaMessage = outgoingMessageBuilder.groupMetaMessage;

    if ([thread isKindOfClass:TSGroupThread.class]) {
        // Unless specified, we assume group messages are "Delivery" i.e. normal messages.
        if (groupMetaMessage == TSGroupMetaMessageUnspecified) {
            _groupMetaMessage = TSGroupMetaMessageDeliver;
        } else {
            _groupMetaMessage = groupMetaMessage;
        }
    } else {
        // Specifying a group meta message only makes sense for Group threads
        _groupMetaMessage = TSGroupMetaMessageUnspecified;
    }

    _isVoiceMessage = outgoingMessageBuilder.isVoiceMessage;

    // New outgoing messages should immediately determine their
    // recipient list from current thread state.
    NSMutableSet<SignalServiceAddress *> *recipientAddresses = [NSMutableSet new];
    

    NSMutableDictionary<SignalServiceAddress *, TSOutgoingMessageRecipientState *> *recipientAddressStates =
        [NSMutableDictionary new];
    for (SignalServiceAddress *recipientAddress in recipientAddresses) {
        if (!recipientAddress.isValid) {
            continue;
        }
        TSOutgoingMessageRecipientState *recipientState = [TSOutgoingMessageRecipientState new];
        recipientState.state = OWSOutgoingMessageRecipientStateSending;
        recipientAddressStates[recipientAddress] = recipientState;
    }
    self.recipientAddressStates = [recipientAddressStates copy];
    _outgoingMessageSchemaVersion = TSOutgoingMessageSchemaVersion;

    _changeActionsProtoData = outgoingMessageBuilder.changeActionsProtoData;

    return self;
}

// Each message has the responsibility for eagerly cleaning up its attachments.
// Normally this is done in [TSMessage removeWithTransaction], but that doesn't
// apply for "transient", unsaved messages (i.e. shouldBeSaved == NO).  These
// messages need to be cleaned up explicitly.
- (void)removeTemporaryAttachmentsWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    if (self.shouldBeSaved) {
        return;
    }
    if (!AppReadiness.isAppReady) {
        // We don't want or need to do this clean up while registering extensions,
        // migrating, etc.
        return;
    }
    NSArray<NSString *> *_Nullable attachmentIds = self.attachmentIds;
    if (attachmentIds.count < 1) {
        return;
    }
    for (NSString *attachmentId in attachmentIds) {
        // We need to fetch each attachment, since [TSAttachment removeWithTransaction:] does important work.
        TSAttachment *_Nullable attachment = [TSAttachment anyFetchWithUniqueId:attachmentId transaction:transaction];
        if (!attachment) {
            continue;
        }
        [attachment anyRemoveWithTransaction:transaction];
    };
}

#pragma mark -

- (TSOutgoingMessageState)messageState
{
    TSOutgoingMessageState newMessageState =
        [TSOutgoingMessage messageStateForRecipientStates:self.recipientAddressStates.allValues];
    if (self.hasLegacyMessageState) {
        if (newMessageState == TSOutgoingMessageStateSent || self.legacyMessageState == TSOutgoingMessageStateSent) {
            return TSOutgoingMessageStateSent;
        }
    }
    return newMessageState;
}

- (BOOL)wasDeliveredToAnyRecipient
{
    if (self.deliveredRecipientAddresses.count > 0) {
        return YES;
    }
    return (self.hasLegacyMessageState && self.legacyWasDelivered && self.messageState == TSOutgoingMessageStateSent);
}

- (BOOL)wasSentToAnyRecipient
{
    if (self.sentRecipientAddresses.count > 0) {
        return YES;
    }
    return (self.hasLegacyMessageState && self.messageState == TSOutgoingMessageStateSent);
}

+ (TSOutgoingMessageState)messageStateForRecipientStates:(NSArray<TSOutgoingMessageRecipientState *> *)recipientStates
{

    // If there are any "sending" recipients, consider this message "sending".
    // If there are any "pending" recipients, consider this message "pending".
    BOOL hasFailed = NO;
    for (TSOutgoingMessageRecipientState *recipientState in recipientStates) {
        if (recipientState.state == OWSOutgoingMessageRecipientStateSending) {
            return TSOutgoingMessageStateSending;
        } else if (recipientState.state == OWSOutgoingMessageRecipientStatePending) {
            return TSOutgoingMessageStatePending;
        } else if (recipientState.state == OWSOutgoingMessageRecipientStateFailed) {
            hasFailed = YES;
        }
    }

    // If there are any "failed" recipients, consider this message "failed".
    if (hasFailed) {
        return TSOutgoingMessageStateFailed;
    }

    // Otherwise, consider the message "sent".
    //
    // NOTE: This includes messages with no recipients.
    return TSOutgoingMessageStateSent;
}

- (BOOL)shouldBeSaved
{
    if (!super.shouldBeSaved) {
        return NO;
    }
    if (self.groupMetaMessage == TSGroupMetaMessageDeliver || self.groupMetaMessage == TSGroupMetaMessageUnspecified) {
        return YES;
    }
    return NO;
}

- (void)anyWillInsertWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyWillInsertWithTransaction:transaction];

    _storedMessageState = self.messageState;
}

- (void)anyDidInsertWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyDidInsertWithTransaction:transaction];
    if (self.sendingRecipientAddresses.count == 0) {
    }
}

- (void)anyWillUpdateWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyWillUpdateWithTransaction:transaction];

    _storedMessageState = self.messageState;
}

- (void)anyDidUpdateWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyDidUpdateWithTransaction:transaction];
    if (self.sendingRecipientAddresses.count == 0) {
    }
}

// This method will be called after every insert and update, so it needs
// to be cheap.
- (BOOL)shouldStartExpireTimer
{
    if (self.hasPerConversationExpirationStarted) {
        // Expiration already started.
        return YES;
    } else if (!self.hasPerConversationExpiration) {
        return NO;
    } else if (!super.shouldStartExpireTimer) {
        return NO;
    }

    // It's not clear if we should wait until _all_ recipients have reached "sent or later"
    // (which could never occur if one group member is unregistered) or only wait until
    // the first recipient has reached "sent or later" (which could cause partially delivered
    // messages to expire).  For now, we'll do the latter.
    //
    // TODO: Revisit this decision.
    return self.messageState == TSOutgoingMessageStateSent;
}

- (BOOL)isOnline
{
    return NO;
}

- (OWSInteractionType)interactionType
{
    return OWSInteractionType_OutgoingMessage;
}

- (NSArray<SignalServiceAddress *> *)recipientAddresses
{
    return self.recipientAddressStates.allKeys;
}

- (NSArray<SignalServiceAddress *> *)sendingRecipientAddresses
{
    NSMutableArray<SignalServiceAddress *> *result = [NSMutableArray new];
    for (SignalServiceAddress *recipientAddress in self.recipientAddressStates) {
        TSOutgoingMessageRecipientState *recipientState = self.recipientAddressStates[recipientAddress];
        if (recipientState.state == OWSOutgoingMessageRecipientStateSending
            || recipientState.state == OWSOutgoingMessageRecipientStatePending) {
            [result addObject:recipientAddress];
        }
    }
    return result;
}

- (NSArray<SignalServiceAddress *> *)sentRecipientAddresses
{
    NSMutableArray<SignalServiceAddress *> *result = [NSMutableArray new];
    for (SignalServiceAddress *recipientAddress in self.recipientAddressStates) {
        TSOutgoingMessageRecipientState *recipientState = self.recipientAddressStates[recipientAddress];
        if (recipientState.state == OWSOutgoingMessageRecipientStateSent) {
            [result addObject:recipientAddress];
        }
    }
    return result;
}

- (NSArray<SignalServiceAddress *> *)deliveredRecipientAddresses
{
    NSMutableArray<SignalServiceAddress *> *result = [NSMutableArray new];
    for (SignalServiceAddress *recipientAddress in self.recipientAddressStates) {
        TSOutgoingMessageRecipientState *recipientState = self.recipientAddressStates[recipientAddress];
        if (recipientState.deliveryTimestamp != nil) {
            [result addObject:recipientAddress];
        }
    }
    return result;
}

- (NSArray<SignalServiceAddress *> *)readRecipientAddresses
{
    NSMutableArray<SignalServiceAddress *> *result = [NSMutableArray new];
    for (SignalServiceAddress *recipientAddress in self.recipientAddressStates) {
        TSOutgoingMessageRecipientState *recipientState = self.recipientAddressStates[recipientAddress];
        if (recipientState.readTimestamp != nil) {
            [result addObject:recipientAddress];
        }
    }
    return result;
}

- (NSArray<SignalServiceAddress *> *)viewedRecipientAddresses
{
    NSMutableArray<SignalServiceAddress *> *result = [NSMutableArray new];
    for (SignalServiceAddress *recipientAddress in self.recipientAddressStates) {
        TSOutgoingMessageRecipientState *recipientState = self.recipientAddressStates[recipientAddress];
        if (recipientState.viewedTimestamp != nil) {
            [result addObject:recipientAddress];
        }
    }
    return result;
}

- (NSUInteger)sentRecipientsCount
{
    return [self.recipientAddressStates
                .allValues filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(
                                                           TSOutgoingMessageRecipientState *recipientState,
                                                           NSDictionary<NSString *, id> *_Nullable bindings) {
        return recipientState.state == OWSOutgoingMessageRecipientStateSent;
    }]].count;
}

- (nullable TSOutgoingMessageRecipientState *)recipientStateForAddress:(SignalServiceAddress *)address
{
    TSOutgoingMessageRecipientState *_Nullable result = self.recipientAddressStates[address];
    return [result copy];
}

#pragma mark - Update With... Methods

- (void)updateWithSendingError:(NSError *)error transaction:(SDSAnyWriteTransaction *)transaction
{
    
}

- (void)updateWithAllSendingRecipientsMarkedAsFailedWithTransaction:(SDSAnyWriteTransaction *)transaction
{

    
}

- (BOOL)hasFailedRecipients
{
    for (TSOutgoingMessageRecipientState *recipientState in self.recipientAddressStates.allValues) {
        if (recipientState.state == OWSOutgoingMessageRecipientStateFailed) {
            return YES;
        }
    }
    return NO;
}

- (void)updateAllUnsentRecipientsAsSendingWithTransaction:(SDSAnyWriteTransaction *)transaction
{

   
}

- (void)updateWithHasSyncedTranscript:(BOOL)hasSyncedTranscript transaction:(SDSAnyWriteTransaction *)transaction
{
    
}

- (void)updateWithSentRecipient:(SignalServiceAddress *)recipientAddress
                    wasSentByUD:(BOOL)wasSentByUD
                    transaction:(SDSAnyWriteTransaction *)transaction
{

    
}

- (void)updateWithSkippedRecipient:(SignalServiceAddress *)recipientAddress
                       transaction:(SDSAnyWriteTransaction *)transaction
{

   
}

- (void)updateWithFailedRecipient:(SignalServiceAddress *)recipientAddress
                            error:(NSError *)error
                      transaction:(SDSAnyWriteTransaction *)transaction
{

    
}

- (void)updateWithDeliveredRecipient:(SignalServiceAddress *)recipientAddress
                   recipientDeviceId:(uint32_t)deviceId
                   deliveryTimestamp:(NSNumber *_Nullable)deliveryTimestamp
                         transaction:(SDSAnyWriteTransaction *)transaction
{

    // Ignore receipts for messages that have been deleted.
    // They are no longer relevant to this message.
    if (self.wasRemotelyDeleted) {
        return;
    }

    // If delivery notification doesn't include timestamp, use "now" as an estimate.
    if (!deliveryTimestamp) {
        deliveryTimestamp = @([NSDate ows_millisecondTimeStamp]);
    }

    [self clearMessageSendLogEntryForRecipient:recipientAddress
                                      deviceId:deviceId
                                   transaction:transaction];

   
}

- (void)updateWithReadRecipient:(SignalServiceAddress *)recipientAddress
              recipientDeviceId:(uint32_t)deviceId
                  readTimestamp:(uint64_t)readTimestamp
                    transaction:(SDSAnyWriteTransaction *)transaction
{

    // Ignore receipts for messages that have been deleted.
    // They are no longer relevant to this message.
    if (self.wasRemotelyDeleted) {
        return;
    }

    // This is only really necessary for delivery receipts, but while we're here with
    // an open write transaction, might as well double check we've cleared it.
    [self clearMessageSendLogEntryForRecipient:recipientAddress
                                      deviceId:deviceId
                                   transaction:transaction];

    
}

- (void)updateWithViewedRecipient:(SignalServiceAddress *)recipientAddress
                recipientDeviceId:(uint32_t)deviceId
                  viewedTimestamp:(uint64_t)viewedTimestamp
                      transaction:(SDSAnyWriteTransaction *)transaction
{

    // Ignore receipts for messages that have been deleted.
    // They are no longer relevant to this message.
    if (self.wasRemotelyDeleted) {
        return;
    }

    // This is only really necessary for delivery receipts, but while we're here with
    // an open write transaction, might as well double check we've cleared it.
    [self clearMessageSendLogEntryForRecipient:recipientAddress
                                      deviceId:deviceId
                                   transaction:transaction];

    
}

- (void)updateWithWasSentFromLinkedDeviceWithUDRecipientAddresses:
            (nullable NSArray<SignalServiceAddress *> *)udRecipientAddresses
                                          nonUdRecipientAddresses:
                                              (nullable NSArray<SignalServiceAddress *> *)nonUdRecipientAddresses
                                                     isSentUpdate:(BOOL)isSentUpdate
                                                      transaction:(SDSAnyWriteTransaction *)transaction
{

}

- (void)updateWithSendingToSingleGroupRecipient:(SignalServiceAddress *)singleGroupRecipient
                                    transaction:(SDSAnyWriteTransaction *)transaction
{

   
}

- (nullable NSNumber *)firstRecipientReadTimestamp
{
    NSNumber *result = nil;
    for (TSOutgoingMessageRecipientState *recipientState in self.recipientAddressStates.allValues) {
        if (!recipientState.readTimestamp) {
            continue;
        }
        if (!result || (result.unsignedLongLongValue > recipientState.readTimestamp.unsignedLongLongValue)) {
            result = recipientState.readTimestamp;
        }
    }
    return result;
}

- (void)updateWithRecipientAddressStates:
            (nullable NSDictionary<SignalServiceAddress *, TSOutgoingMessageRecipientState *> *)recipientAddressStates
                             transaction:(SDSAnyWriteTransaction *)transaction
{
    
}

- (void)clearMessageSendLogEntryForRecipient:(SignalServiceAddress *)address
                                    deviceId:(uint32_t)deviceId
                                 transaction:(SDSAnyWriteTransaction *)transaction
{
    // MSL entries will only exist for addresses with UUIDs
}

#ifdef TESTABLE_BUILD
- (void)updateWithFakeMessageState:(TSOutgoingMessageState)messageState
                       transaction:(SDSAnyWriteTransaction *)transaction
{
    
}
#endif

#pragma mark -

- (nullable SSKProtoDataMessageBuilder *)dataMessageBuilderWithThread:(TSThread *)thread
                                                          transaction:(SDSAnyReadTransaction *)transaction
{

    return nil;
}

- (OutgoingGroupProtoResult)addGroupsV1ToDataMessageBuilder:(SSKProtoDataMessageBuilder *)builder
                                                groupThread:(TSGroupThread *)groupThread
                                                transaction:(SDSAnyReadTransaction *)transaction
{
    return  nil;
}

- (OutgoingGroupProtoResult)addGroupsV2ToDataMessageBuilder:(SSKProtoDataMessageBuilder *)builder
                                                groupThread:(TSGroupThread *)groupThread
                                                transaction:(SDSAnyReadTransaction *)transaction
{
    if (![groupThread.groupModel isKindOfClass:[TSGroupModelV2 class]]) {
        return OutgoingGroupProtoResult_Error;
    }

    return OutgoingGroupProtoResult_AddedWithoutGroupAvatar;
}

- (BOOL)shouldSyncTranscript
{
    return YES;
}

- (NSString *)statusDescription
{
    NSMutableString *result = [NSMutableString new];
    [result appendFormat:@"[status: %@\n", NSStringForOutgoingMessageState(self.messageState)];
    for (SignalServiceAddress *address in self.recipientAddressStates) {
        TSOutgoingMessageRecipientState *recipientState = self.recipientAddressStates[address];
        [result appendFormat:@", %@: %@\n", address, NSStringForOutgoingMessageRecipientState(recipientState.state)];
    }
    [result appendString:@"]"];
    return [result copy];
}

@end

NS_ASSUME_NONNULL_END
